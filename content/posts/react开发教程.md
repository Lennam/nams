---
title: "React 开发教程"
date: 2018-11-30T21:37:10+08:00
draft: true
---

 最近学了React，所以把自己学习React的笔记整理一下变成了这篇入门教程。

React官方文档描述React为函数式的，有的同学可能不太明白，前端明明涉及那么多有副作用的操作，例如DOM的操作和API的请求之类，为什么React会称自己为函数式的呢？

我们知道，无论是React、Vue或是Angular，它们的最终目的都是生成视图，而视图则是对当前数据的一种映射，在MVVM（关于MVVM可以参考我的另一篇博客）模式里面，我们并不直接操作View层，而是交给VM层自动生成，所以MVVM模式框架生成视图的过程中，我们可以看做：

数据  +  Render = 视图

而MVVM模式的框架在生成视图的过程中就扮演了Render的角色。在函数式编程中，当一个函数接受相同的参数，它总是返回相同的结果。而在React中，我们提供了相同的数据，React总是渲染出相同的视图。那些带有副作用的操作，DOM改变和API请求，会先改变数据，然后经过Render最终改变视图，这就是React不建议我们直接操作DOM的原因，这会让视图的生成不可预测，并增加测试的难度。

那么我们如何使用React来构建视图呢？

过去我们不使用React之类的框架时，总是用一个HTML文件来表示一个用户界面，然而一个用户界面在很多时候是复杂的，当产生变化的时候，经常伴随许多DOM操作，所有我们还要提供一个又臭又长的js文件来维护用户界面的变化，当应用越来越懒复杂，用户界面越来越多的时候，可以预见这将是一场灾难。那如果我们不按用户界面来拆分应用呢？我们是否可以把用户界面看做一个个小的视图组成，每一个视图完成一个功能？显然，React这样做了。

在React中，推荐使用jsx来描述UI信息（你也可以使用其他的语言，但是React弄了一个视频来忽悠你），每一个jsx文件代表一个组件，我们需要根据单一职责原则把一个用户界面拆分为许多组件，组件分为函数式组件（或者称为无状态组件）和类组件，无论是函数式组件还是类组件都会返回一个React元素，这个过程是通过Babel把jsx编译成React.createElement()执行的：

图。。。

函数式组件形如一个javascript函数，它只接受props参数，并返回一个React元素，当我们使用函数式组件的时候，往往只把这个组件用于展示props传入的数据，而没有其他的逻辑，例如对用户的操作作出响应等，所以函数式组件没有自己内部的状态。我们可以看作：给它什么，它就显示并只专注于显示什么。你或许了解函数式编程，函数式组件也一样，当我们使用它的时候，应该禁止其修改传入的props。

图

而在类组件中，组件获得了更多的能力。它可以拥有自己的State（状态），同时它还拥有了在组件不同的生命周期里编写逻辑的能力，从而可以响应更复杂的变化。

（显然，在Facebook内部可能更喜欢函数式组件，否则它们就不会为函数式组件提供新特性Hooks并推荐你在新的代码中使用它了。）

假如我们现在要实现一个功能：有一个搜索框和一个表格用于搜索和展示电影。

首先拆分组件。我们可以把整个功能先看成一个组件，它实现了搜索和展示的功能，这样做当然可以，但如果在应用的另一个地方要实现某个单一的搜索或者展示功能呢？诚然，这样让组件无法复用。所以我们可以拆分为一个搜索组件和一个展示组件，这样使得我们的组件可以在其他地方复用（在应用的设计阶段可以和设计师沟通，把有相同功能的页面设计为一致的风格，如果他要为相同的功能都重新设计，那么就祝你幸福吧）。

现在我们把这个功能拆分为如下的组件构成：

图。。。

我们该如何选择函数式组件和类组件呢？

一个简单的方法就是我们先用类组件构建所有的组件，只实现功能的静态页面版本（只有界面，而没有任何的交互，只需要编写类组件里的render方法），并模拟一个电影数组，通过props传入MovieFilterableTable,然后再传入MovieTable组件。

显然，这个静态页面版本无法满足我们的功能需求，我们的组件需要更多的交互，React为我们提供了State来触发和更改底层的数据模型。

现在列举一下我们功能里的所有数据：

- 搜索文本
- 初始电影列表
- 搜索后的电影列表

为了确定一个数据是不是State，React提供了几个提示：

1. 是否通过 props(属性) 从父级传入？ 如果是这样，它可能不是 state(状态) 。
2. 是否永远不会发生变化？ 如果是这样，它可能不是 state(状态)。
3. 是否可以由组件中其他的 state(状态) 或 props(属性) 计算得出？如果是这样，则它不是 state(状态)。

（你或许觉得啰嗦，当你熟悉了React构建应用后，你可以很快的确定哪些数据是state，哪些是props）

搜索文本不是通过props传入，会随着用户的输入改变。初始电影列表通过props传递，而搜索后的电影列表可以通过初试电影列表结合搜索文本计算得出。

所以在这个功能中，状态只有：

- 搜索文本

接下来我们要思考该把这个state放在那个组件当中。在React中，数据自顶向下流动，假如搜索文本只有在SearchBar中才使用，那放入SearchBar或许是不错的选择，但在这个例子中，我们的MovieTable组件也需要搜索文本来决定需要展示哪些Movie，MovieTable和SearchBar处于同级，这会让state的共享变得困难，所以把它放入公共父组件并通过props传入SearchBar和MovieTable会是不错的选择。

对于State应该存放在哪个组件当中，React为我们提供了一些建议：

- 确定每个基于这个 state(状态) 渲染的组件。
- 找出公共父级组件（一个单独的组件，在组件层级中位于所有需要这个 state(状态) 的组件的上面。愚人码头注：父级组件）。
- 公共父级组件 或者 另一个更高级组件拥有这个 state(状态) 。
- 如果找不出一个拥有该 state(状态) 的合适组件，可以创建一个简单的新组件来保留这个 state(状态) ，并将其添加到公共父级组件的上层即可。

（State和Props的规划，是React中非常重要的一部分，这往往会影响到你对应用的理解和代码的整洁）

看起来我们已经让这个功能具备了正确的数据流，但我们似乎忽略了一点：SearchBar需要更改搜索文本这个State该怎么做？

由于组件只能修改自己的State，但是搜索文本是存放在父组件中通过props传入SearchBar的，当用户输入新的文本时，我们可以使用OnChange监听用户的输入，然后通过父组件传入的回调调用setState，然后应用就被更新。

到这一步我们就把一个简单的功能实现了，对于React应用而言，就是由许多个这样的功能组件组合而成：

图。。。。

这种模块化、可复用的代码结构在我们构建大型应用的时候变得更加容易