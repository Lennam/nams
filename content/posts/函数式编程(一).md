---
title: "函数式编程(一)"
date: 2019-04-07T14:15:39+08:00
draft: false
---

在了解函数式编程之前，我们先来讨论一个问题：什么函数？

编程时，我们在谈论函数的时候，总是默认它为命令式编程里的**子程序。**

![image](/functional/image-20200407142018417.png)

子程序，英文里称为subroutine或者subprogram，顾名思义，就是指一个计算机程序中的某部分代码，它由一个或多个语句块组成它负责完成某项特定任务，而且相较于其他代码，具备相对的独立性。

```javascript
function (x) {
   …
}
```

它一般类似于这种形式，会有输入参数并有返回值，提供对过程的封装和细节的隐藏，但是，在我们接下来的讨论中，我希望大家忘记函数的这种形式，因为我们即将进入**数学里的函数**，如果你把编程时常写x=x+1给你的数学老师看，他应该会打你吧。

在数学里，我们可以把函数看作两个不为空的集合间的一种对应关系，输入值集合中的每项元素皆能对应唯一一项输出值集合中的元素。例如实数x对应到其平方x2的关系就是一个函数，若以3作为此函数的输入值，所得的输出值便是9：

![image](/functional/image-20200407142331767.png)

我们用数学式把这个关系写出来就是一个我们每个人都见过的式子：

![image](/functional/image-20200407142436016.png)

函数将有效的输入值变换为唯一的输出值，同一输入总是对应同一输出，但反之未必成立。因此如Root(x)=正负sqrt(x)这样的表达式并没有定义出一个函数，因为输出值有两个可能。定义函数时需确定每一个输入值只对应唯一输出值，因此必须明确地选择一个平方根。例如定义Posroot(x)=sqrt(x)，亦即对于任何非负输入值，选择其非负平方根作为函数值。

那么什么是函数式编程呢？

我们先对它下一个定义：它是一种以**Lambda**为其语言基础的**编程范式**，就像面向对象编程，命令式编程一样，是一类典型的**编程风格**。

Lambda演算是一套从数学逻辑中发展，以变量绑定和替换的规则，来研究函数如何抽象化定义、函数如何被应用以及递归的形式系统。它是一种抽象计算模型，是解决可计算问题的一种方案，通俗来讲，就是将计算以数学的方式抽象化，以便证明和推导。

Lambda演算的定义为：

![image](/functional/image-20200407143151599.png)

比如我们定一个lambda表达式：

![image](/functional/image-20200407143314009.png)

当这个表达式应用于具体的变量时，需要用一对括号把表达式括起来，应用过程是把变量值赋值给表达式中的x，并去掉 λ<变量>：

![image](/functional/image-20200407143405738.png)

看到这里是不是熟悉了很多，这其实就对应着程序语言中的**函数定义，参数传递，函数调用**。函数式编程语言Lisp表达的也正是这种形式。

那如果是多个变量呢？

![image](/functional/image-20200407143717049.png)

可能有人会有疑问，如果以lambda演算为语言基础，那么语言中的boolean、number、list这些数据类型怎么办？

有这种疑问的同学，你距离真正的乐趣已经很近了，Lambda演算有其强大的秘笈，那就是**不关心数据的值是什么，重点是能对这个值做什么操作**。

以布尔值为例大家想一想我们平时都把布尔值用在什么地方？

对，条件判断。

因为其实我们是无法直观的看出一个值是true还是false，而是根据条件判断返回的值来判断，在Lambda演算中，我们可以这样定义布尔值（感兴趣的同学可以自己去搜索一下推导过程）：

![image](/functional/image-20200407144303904.png)

介绍完Lambda，下面我们来定义一下函数式编程范式：

在函数式的编程范式里，把计算机运算视为函数运算，也就是说一个程序会被看作是一个无状态的函数计算的序列；最后，在函数式编程里，应该避免使用程序状态以及易变对象。

之前我们介绍了的数学里的函数，函数的运算，也就是一个映射的过程。这听起来很抽象，我们先来举个例子，假如现在你正在面试，面试官出了一道题给你：把二叉树镜像翻转一下。然后你不假思索，写下了如下代码：

```javascript
function invertTree(node) {
    if (!node) return;
    [node.left, node.right] = [invertTree(node.right), invertTree(node.left)];
    return node;
}
```

好了，我们现在停下来看看这段代码究竟代表着什么：首先判断节点是否为空；然后翻转左树；然后翻转右树；最后左右互换。这就是命令式编程——你要做什么事情，你得把达到目的的步骤详细的描述出来，然后交给机器去运行。

这也正是命令式编程的理论模型——图灵机的特点。一条写满数据的纸带，一条根据纸带内容运动的机器，机器每动一步都需要纸带上写着如何达到。

我们用函数的思维来重新思考一下这个问题，所谓“翻转二叉树”，可以看做是要得到一颗和原来二叉树对称的新二叉树。这颗新二叉树的特点是每一个节点都递归地和原树相反。基于这种映射关系，我们重新写出以下的代码：

```javascript
function invertTree(node) {
  // 省略Tree和invert的实现
    if(!node) return;
    return Tree(node.value, invert(node.right), invert(node.left));
}
```

乍一看与之前的代码区别并不大，只是创建了一个新的树并返回，但其得到结果的方式与之前的代码有着本质的差别，这段代码通过描述一个**旧树->新树的映射**，而不是描述「从旧树得到新树应该怎样做」来达到目的。

这就是函数运算，它是**“对映射和关系的描述”**，它不仅可以描述二叉树这样的数据结构之间的对应关系，任何能在计算机中体现的东西之间的对应关系都可以描述——比如函数和函数之间的映射；比如外部操作到 GUI 之间的映射。我们把寻找这种映射关系的过程抽象，也就是推导lambda演算的过程。

正如平时我们都知道的函数式法则一样，不要去修改传入的值，而是根据它去计算一个新的值。这正是imutable的思想，也是之后React、Redux等框架的基石。

但凡事都有正反两面，函数式编程也不例外。

首先最明显的好处就是引用透明和没有副作用，函数调用的结果不依赖调用的时间和位置，对于相同的输入，函数总是返回相同的输出，这样写的代码容易进行推理，不容易出错。这使得单元测试和调试都更容易。此外，如今计算机计算能力的增长已经不依赖CPU主频的增长，而是依赖CPU核数的增多，在多核环境下的程序设计的难点就在于对共享可变状态的管理，函数即不依赖外部的状态也不修改外部的状态，使得并行更加容易。而函数作为一等公民，可以在任何地方定义，在函数内或函数外，可以作为函数的参数和返回值，也可以对函数进行组合。

当然，它的缺点也很明显：

如果某个映射关系很复杂，需要许多函数组合运算，过长的函数组合可能会影响代码的可读性。其次在函数式编程中没有循环，所以必须使用递归来达到循环的功能，这对编写带来了挑战，因为没有可变的状态来存储中间值，在一些复杂运算中需要更多的内存和计算时间，这将导致性能的下降。

---

函数式编程可能听起来高大上，实际上也不过是众多编程范式的一种，学会函数式编程，并不代表拥有了屠龙的宝刀。对于计算机科学而言，核心永远应该是“**如何解决问题**”，而不是“**这个概念、架构、模型、语言能够做什么**”。就连计算机本身，最初都是为了军事上的目标而被创造出来的。是“**要解决的问题**”决定了计算机是什么样子，计算机科学是什么样子，而不是反之。

所以就程序的编写而言，写下代码只是最后的一步。**对问题的理解、对解决方案的理解才是重心**。“解决方案”在想好之后，再被映射到程序设计语言中。

希望大家知道为什么以及何时使用，而不是单纯的为了使用而使用。



